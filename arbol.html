<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Automata</title>

   
	<link rel="stylesheet" type="text/css" href="estilo.css">
   <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
<!-- To automatically render math in text elements -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>

</head>
<body>
	

	<div class="container-fluid">


  		<h3 class="mt-5"> Implementación de Árbol rojo-negro en C# en Consola</h3>
		<p>
	Los árboles son estructura de datos compuesta por nodos y con una distribución jerárquica. Un árbol cuenta con un nodo raíz y nodos hijos que a su vez pueden tener descendencia.
  Los árboles rojo-negro son binarios auto balanceados, es decir, tienen mecanismos para modificar la estructura del árbol en las inserciones y eliminaciones en función de los requerimientos de cada uno.
		
    </p>
<p>
  Son muy similares a los árboles AVL aunque tienen la característica adicional que los nodos tienen un color rojo o negro. La altura no se rige como en el AVL, en cambio, se rige por el numero de nodos rojos que existen desde la hoja más profunda descendiente hasta el nodo.
</p>
      <p> Las inserciones y eliminaciones se basaron en  este <a href="https://www.infor.uva.es/~cvaca/asigs/doceda/rojonegro.pdf">material</a> donde se explican los mecanismos de rotación que árbol debe cumplir.</p>

<h3>Código del programa en C#</h3>
Al ser un código muy extenso se muestra solo partes de este.
<pre><code class="language-C#">
  //Clase Nodo de los árboles
  class Nodo
  {
      private int dato;
      private Nodo hijoIzquierdo;
      private Nodo hijoDerecho;
      private int fE;
      private char color;
      int nAltura;
      public Nodo(int d)
      {
          color = 'r';
          Dato = d;
          HijoDerecho = null;
          HijoIzquierdo = null;
          FE = 0;
          NAltura = -1;

      }
      public Nodo()
      {
          color = 'r';
          Dato = 0;
          HijoDerecho = null;
          HijoIzquierdo = null;
          FE = 0;
          NAltura = -1;

      }
    }

</code></pre>
<p>Clase Árbol</p>
<pre><code class="language-C#">
  //Clase arbol rojo-negro con algunos de sus métodos
   class Arbol
 {
     private Nodo raiz;
     private Nodo NRotar;
     internal Nodo Raiz { get => raiz; set => raiz = value; }
     public Arbol()
     {
         Raiz = null;
         NRotar = null;
     }
     public bool Vacio()
     {
         return Raiz == null;
     }
     private Nodo CreaNodo(int dato, char n)
     {
         Nodo Nuevo = new Nodo(dato);
         Nuevo.Color= n;
         return Nuevo;
     }
     public void Insertar(int dato)
     {
         Nodo x;
         if (Vacio())
             Raiz = CreaNodo(dato,'n');
         else
             AgregaNodo(dato, Raiz);
         x = BuscaRegresaDireccion(Raiz, dato);
         VerificaCaso(x);
        Raiz.Color = 'n';


     }
     public void AgregaNodo(int dato, Nodo Dir)
     {

         if (dato < Dir.Dato)
             if (Dir.HijoIzquierdo == null)
                 Dir.HijoIzquierdo = CreaNodo(dato,'r');
             else
                 AgregaNodo(dato, Dir.HijoIzquierdo);
         else
              if (Dir.HijoDerecho == null)
                       Dir.HijoDerecho = CreaNodo(dato,'r');
         else
             AgregaNodo(dato, Dir.HijoDerecho);

     }
        public void Borrado(Nodo Dir,int valor)
   {
       Nodo aux;
       Nodo padre;
       if (Dir == null)
           return;

       if (valor < Dir.Dato)
               Borrado(Dir.HijoIzquierdo, valor);
       else
           if (valor > Dir.Dato)
                 Borrado(Dir.HijoDerecho, valor);
       else //ESTOY EN EL NODO A ELIMINAR
       {
           //VERIFICAR QUE TENGA 2 HIJOS
           if (Dir.HijoIzquierdo != null)
           {
               if (Dir.HijoDerecho != null) // TIENE 2 HIJOS
               {
                   int var;
                       aux = BuscaPequeño(Dir.HijoDerecho);
                       var = Dir.Dato;
                       padre = ObtenerPadre(raiz, aux.Dato);
                       Dir.Dato = aux.Dato; // intercambio de datos
                     aux.Dato = var;
                       Restructura( padre,aux); // va a borrar el nodo mayor de la izquierda // caera en los otros caso                
               }
               else
               {
                   padre=ObtenerPadre(raiz, Dir.Dato);
                   Restructura(padre, Dir); // solo tiene hijo izquierdo
                   return;
               }
           }
           else
           {
               if (Dir.HijoDerecho != null)
               {
                   padre = ObtenerPadre(raiz, Dir.Dato);

                   Restructura(padre, Dir); //tiene solo hijo derecho
                   return;
               }
               else
               {
                   padre=ObtenerPadre(raiz, Dir.Dato);
                   Restructura(padre, Dir); // no tiene hijos
                   return;
               }
           }
        }
   
       ImprimeArbol(raiz,0);
           }


}
</code></pre>
	<p>Para ver toda la implementación consultar en el <a href="https://github.com/PabloHO25/ArbolRojoNegro"> repositorio</a>.</p>


	

</div>
   


</body>
</html>
